'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IgnoreField = exports.IncludeAll = exports.ApolloProjector = exports.toMongoProjection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = projector;

var _type = require('graphql/type');

var _graphqlTools = require('graphql-tools');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Attempt to grab the type name from a GraphQL return type. E.g., if it's a null or a list
 * we only care about the inner guts.
 */
function getTypeName(returnType) {
  var namedType = (0, _type.getNamedType)(returnType);
  if (namedType) {
    while (namedType.ofType) {
      namedType = namedType.ofType;
    }
    return namedType;
  }
  throw new Error('Could not detect return type');
}

function replaceFragments(selectionSet, fragments) {
  if (!selectionSet) {
    return [];
  }

  return selectionSet.selections.reduce(function (accumulator, selection) {
    if (selection.kind === 'Field') {
      return [].concat(_toConsumableArray(accumulator), [selection]);
    }
    if (selection.kind !== 'FragmentSpread') {
      // todo: Figure out what we need to do to handle this case
      throw new Error('Unable to handle SelectionNode of type \'' + selection.kind + '\'');
    }
    var fragment = fragments[selection.name.value];
    if (!fragment) {
      throw new Error('Unable to find fragment for selection \'' + selection.name.value + '\'');
    }
    // Step through this fragment recursively in case it is also made up of fragments
    var fragmentSelections = replaceFragments(fragment.selectionSet, fragments);
    return [].concat(_toConsumableArray(accumulator), _toConsumableArray(fragmentSelections));
  }, []);
}

function projector(_ref) {
  var fieldNodes = _ref.fieldNodes,
      returnType = _ref.returnType,
      fragments = _ref.fragments,
      schema = _ref.schema;

  var projection = {};
  var typeName = getTypeName(returnType).name;
  fieldNodes.forEach(function (fieldNode) {
    // Ensure all of the selection sets through the tree aren't fragments
    var selections = replaceFragments(fieldNode.selectionSet, fragments);
    selections.forEach(function (selection) {
      var fieldName = selection.name.value;
      /* eslint-disable no-underscore-dangle */
      var type = schema._typeMap[typeName];
      var field = type.getFields()[fieldName];
      if (!field) {
        projection[fieldName] = 1;
        return;
      }
      var customProjection = field.projection;
      if (customProjection) {
        if (!Array.isArray(customProjection)) {
          customProjection = [customProjection];
        }
        customProjection.forEach(function (fname) {
          projection[fname] = 1;
        });
        return;
      }
      if (field.nameInDB) {
        fieldName = field.nameInDB;
      }
      // if complex type
      if (selection.selectionSet) {
        projection[fieldName] = {};
        var innerResult = projector({
          fieldNodes: [selection],
          returnType: field.type,
          fragments: fragments,
          schema: schema });
        // eslint-disable-next-line
        for (var key in innerResult) {
          projection[fieldName][key] = innerResult[key];
        }
      } else {
        projection[fieldName] = 1;
      }
    });
  });
  return projection;
}

function toMongoProjection(projection) {
  var result = {};
  // eslint-disable-next-line
  for (var key in projection) {
    if (projection[key] === 1) {
      result[key] = 1;
    } else {
      // eslint-disable-next-line
      for (var inKey in toMongoProjection(projection[key])) {
        result[key + '.' + inKey] = 1;
      }
    }
  }
  return result;
}

var ApolloProjector = function (_SchemaDirectiveVisit) {
  _inherits(ApolloProjector, _SchemaDirectiveVisit);

  function ApolloProjector() {
    _classCallCheck(this, ApolloProjector);

    return _possibleConstructorReturn(this, (ApolloProjector.__proto__ || Object.getPrototypeOf(ApolloProjector)).apply(this, arguments));
  }

  _createClass(ApolloProjector, [{
    key: 'visitFieldDefinition',
    value: function visitFieldDefinition(field) {
      var _args = this.args,
          projection = _args.projection,
          projections = _args.projections,
          nameInDB = _args.nameInDB;

      field.projection = projection || projections; // eslint-disable-line
      field.nameInDB = nameInDB; // eslint-disable-line
    }
  }]);

  return ApolloProjector;
}(_graphqlTools.SchemaDirectiveVisitor);

var IncludeAll = function (_SchemaDirectiveVisit2) {
  _inherits(IncludeAll, _SchemaDirectiveVisit2);

  function IncludeAll() {
    _classCallCheck(this, IncludeAll);

    return _possibleConstructorReturn(this, (IncludeAll.__proto__ || Object.getPrototypeOf(IncludeAll)).apply(this, arguments));
  }

  _createClass(IncludeAll, [{
    key: 'visitFieldDefinition',
    value: function visitFieldDefinition(field) {
      field.projection = field.name;
    }
  }]);

  return IncludeAll;
}(_graphqlTools.SchemaDirectiveVisitor);

var IgnoreField = function (_SchemaDirectiveVisit3) {
  _inherits(IgnoreField, _SchemaDirectiveVisit3);

  function IgnoreField() {
    _classCallCheck(this, IgnoreField);

    return _possibleConstructorReturn(this, (IgnoreField.__proto__ || Object.getPrototypeOf(IgnoreField)).apply(this, arguments));
  }

  _createClass(IgnoreField, [{
    key: 'visitFieldDefinition',
    value: function visitFieldDefinition(field) {
      field.projection = [];
    }
  }]);

  return IgnoreField;
}(_graphqlTools.SchemaDirectiveVisitor);

exports.toMongoProjection = toMongoProjection;
exports.ApolloProjector = ApolloProjector;
exports.IncludeAll = IncludeAll;
exports.IgnoreField = IgnoreField;